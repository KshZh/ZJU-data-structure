1-1
无向连通图所有顶点的度之和为偶数。 
T

解析：
一条边贡献两个度，总的就是偶数个度。

1-2
n!是O(n^n)的。 
T

解析：
这道题不懂。

1-3
对N个不同的数据采用冒泡排序进行从大到小的排序，当元素基本有序时交换元素次数肯定最多。 
F

解析：
完全逆序才是最多的，基本有序就不需要什么交换。

1-4
若用平方探测法解决冲突，则插入新元素时，若散列表容量为质数，插入就一定可以成功。 

F

解析：
显然，如果表满了，就无法插入。至于表不满的情况，不知道。

1-5
对一棵平衡二叉树，所有非叶结点的平衡因子都是0，当且仅当该树是完全二叉树。

F

解析：
当完全二叉树在最后一层没有填满的话，平衡因子是1。



2-1
将1~6这6个键值插到一棵初始为空的二叉搜索树中。如果插入完成后，搜索树结构如图所示，问：可能的插入序列是什么？ 
4 1 3 2 5 6

2-2
将 8, 9, 7, 2, 3, 5, 6, 4 顺序插入一棵初始为空的AVL树。下列句子中哪句是错的？ 

2-3
在拓扑排序算法中用堆栈和用队列产生的结果会不同吗？
有可能会不同

解析：
当只有起点的时候。

2-4
对于序列{ 49，38，65，97，76，13，27，50 }，按由小到大进行排序，下面哪一个是初始步长为4的希尔排序法第一趟的结果？ 
49,13,27,50,76,38,65,97

解析：
手动执行一下希尔排序即可。

2-5
给定有权无向图的邻接矩阵如下，其最小生成树的总权重是：

2-6
设栈S和队列Q的初始状态均为空，元素a、b、c、d、e、f、g依次进入栈S。若每个元素出栈后立即进入队列Q，且7个元素出队的顺序是b、d、c、f、e、a、g，则栈S的容量至少是： 

解析：
模拟入栈出栈过程即可。

2-7
给定一有向图的邻接表如下。若从v1开始利用此邻接表做广度优先搜索得到的顶点序列为：{v1, v3, v2, v4, v5}，则该邻接表中顺序填空的结果应为： 

2-8
设散列表的地址区间为[0,16]，散列函数为H(Key)=Key%17。采用线性探测法处理冲突，并将关键字序列{ 26，25，72，38，8，18，59 }依次存储到散列表中。元素59存放在散列表中的地址是： 

2-9
已知一棵二叉树的树形如下图所示，其后序序列为{ e, a, c, b, d, g, f }。树中与结点a同层的结点是：

2-10
将10、12、1、14、6、5、8、15、3、9、7逐个按顺序插入到初始为空的最小堆（小根堆）中，然后连续执行两次删除最小元素操作（DeleteMin），此后堆顶的元素是什么？ 

解析：
先把这些元素画成完全二叉树，然后从最后一个父结点开始，调整为最小堆，一直到根。然后执行删除操作。

2-11
若数据元素序列{ 11，12，13，7，8，9，23，4，5 }是采用下列排序方法之一得到的第二趟排序后的结果，则该排序算法只能是： 
冒泡排序
选择排序
插入排序
归并排序

解析：
冒泡排序每一趟会交换一个最大/最小元到最右/左边，所以排除。
选择排序每次会选择未排序部分最小的元素，所以也排除。
归并排序第二趟应该产生有序的四元组，也排除。

2-12
试利用 Dijkstra 算法求下图中从顶点 A 到其他顶点的最短距离及对应的路径。下列那个序列给出了可能的顶点收集顺序？ 

2-13
令P代表入栈，O代表出栈。则将一个字符串3*a+b/c变为3 a * b c / +的堆栈操作序列是哪个？（例如将ABC变成BCA的操作序列是PPOPOO。） 

2-14
在并查集问题中，已知集合元素0~8所以对应的父结点编号值分别是{ 1, -4, 1, 1, -3, 4, 4, 8, -2 }（注：−n表示树根且对应集合大小为n），那么将元素6和8所在的集合合并（要求必须将小集合并到大集合）后，该集合对应的树根和父结点编号值分别是多少？ 

2-15
给定一有向图的邻接表如下。从顶点V1出发按深度优先搜索法进行遍历，则得到的一种顶点序列为： 

2-16
要判断一个整数N（>10）是否素数，我们需要检查3到√N之间是否存在奇数可以整除N。则这个算法的时间复杂度是：
O(√N)

2-17
如果循环队列用大小为m的数组表示，队头位置为front、队列元素个数为size，那么队尾元素位置rear为： 
(front+size-1)%m

解析：
其实这要看实现中，rear指针是右开，还是右闭，其实这两种都是可以的。

2-18
哈夫曼树是n个带权叶子结点构成的所有二叉树中（）最小的二叉树。 
带权路径长度(WPL)

2-19
对给定序列{ 110，119，7，911，114，120，122 }采用次位优先（LSD）的基数排序，则两趟收集后的结果为： 

2-20
给定输入序列 {4371, 1323, 6173, 4199, 4344, 9679, 1989} 以及散列函数 h(X)=X%10。如果用大小为10的散列表，并且用线性探测解决冲突，则输入各项经散列后在表中的下标为：（-1表示相应的插入无法成功）

2-21
数据结构中Dijkstra算法用来解决哪个问题？ 

2-22
将 {28, 15, 42, 18, 22, 5, 40} 逐个按顺序插入到初始为空的最小堆（小根堆）中。则该树的前序遍历结果为：

5-1
本函数的功能是从有N个元素的线性表A中查找第K小的元素。其中函数BuildMaxHeap(H, K)是将元素H[1] ... H[K]调整为一个最大堆。请完成下列填空。
这个算法可以学习一下。

ElementType FindKthSmallest ( int A[], int N, int K )
{   /* it is assumed that K<=N */
    ElementType *H;
    int i, next, child;

    H = (ElementType *)malloc((K+1)*sizeof(ElementType));
    for ( i=1; i<=K; i++ ) H[i] = A[i-1];
    BuildMaxHeap(H, K); // 先把前K个做成最大堆，堆顶就是第K个最大的元素。

    for ( next=K; next<N; next++ ) {
        H[0] = A[next];
        if ( H[0] < H[1] ) { // 出现比堆顶小的元素，那么堆顶就是第K个最大的元素了，把堆顶删掉，把H[0]插入堆中。
            for ( i=1; i*2<=K; i=child ) {
                child = i*2;
                if ( child!=K && H[child]<H[child+1] ) child++;
                if ( H[0]<H[child] )
                    H[i] = H[child];
                else break;
            }
            H[i] = H[0];
        }
    }
    return H[1];
}

5-2
下列代码的功能是将一列元素{ r[1] … r[n] }按其键值 key 的非递减顺序排序。普通选择排序是每次仅将一个待排序列的最小元放到正确的位置上，而这个另类的选择排序是每次从待排序列中同时找到最小元和最大元，把它们放到最终的正确位置上。

void  sort( list r[], int n )  
{
   int i, j, mini, maxi;

   for (i=1; i<n-i+1; i++) {
      mini = maxi = i;
      for( j=i+1; j<=n-i+1 ; ++j ){
         if( r[j]->key < r[mini]->key ) mini = j; 
         else if(r[j]->key > r[maxi]->key) maxi = j;
      }
      if( mini != i ) swap(&r[mini], &r[i]);
      if( maxi != n-i+1 ){
         if( mini==maxi ) swap(&r[mini], &r[n-i+1]); // 这个条件是错的，不管了。
         else swap(&r[maxi], &r[n-i+1]);
      }
   }
}
部分正确
(7 分)


7-1 还原二叉树 (8分)

```cpp
#include <iostream>
using namespace std;

int N;

char pre[60], in[60];

int height(int pStart, int iStart, int len) {
    if (len <= 0)
        return 0;
    int i;
    char root=pre[pStart];
    for (i=iStart; i<iStart+len && in[i]!=root; i++)
        ;
    int leftLen = i-iStart;
    int rightLen = len-leftLen-1; // 记得减去根。
    return 1+max(height(pStart+1, iStart, leftLen), height(pStart+1+leftLen, i+1, rightLen));
}

int main() {
    int i;
    scanf("%d\n", &N);
    for (i=0; i<N; i++)
        scanf("%c", pre+i);
    scanf("\n");
    for (i=0; i<N; i++)
        scanf("%c", in+i);
    printf("%d\n", height(0, 0, N));
}
```