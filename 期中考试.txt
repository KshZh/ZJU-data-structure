一、判断题：
1-1
一棵有124个结点的完全二叉树，其叶结点个数是确定的。 
T

1-2
若一棵平衡二叉树的所有非叶结点的平衡因子都是0，则其必为完美二叉树。
T

1-3
对于顺序存储的长度为N的线性表，删除第一个元素和插入最后一个元素的时间复杂度分别对应为O(1)和O(N)。 
F
解析：
删除元素要将删除的元素后面的元素往前移动，即便删掉的是第一个元素，除非设计成前端留空。

1-4
用邻接矩阵法存储图，占用的存储空间数只与图中结点个数有关，而与边数无关。 
T

1-5
算法可以没有输入，但是必须有输出。 
T
解析：
累加1到100，就不需要输入，但算法一定要有输出，我们用算法来计算，肯定是要得到它的结果，来进一步利用或者验证，如果算法计算完就直接把结果丢掉了，那就是白白消费计算资源，做无用功。

1-6
若一个栈的输入序列为{1, 2, 3, 4, 5}，则不可能得到{3, 4, 1, 2, 5}这样的出栈序列。 
T

1-7
如果无向图G必须进行两次广度优先搜索才能访问其所有顶点，则G中一定有回路。 
F
解析：
应该是该图有多个连通分量。

1-8
在一棵由包含4、5、6等等一系列整数结点构成的二叉搜索树中，如果结点4和6在树的同一层，那么可以断定结点5一定是结点4和6的父亲结点。 
F
解析：
暂时想不明白。
TODO

1-9
已知一棵二叉树的先序遍历结果是ABC,　则CAB不可能是中序遍历结果。 
T

1-10
所谓“循环队列”是指用单向循环链表或者循环数组表示的队列。 
F
解析：
循环队列是一种设计和思想，指将存储空间的最后一个位置连接到第一个位置，形成逻辑上的环状空间，并不依赖于具体的实现。


二、单选题：
2-1
下列代码
```cpp
for(i=0; i<n; i++)
  for(j=i; j>0; j/=2)
     printf(“%d\n”, j);
```
的时间复杂度是： 
O(NlogN)

2-2
设一段文本中包含4个对象{a,b,c,d}，其出现次数相应为{4,2,5,1}，则该段文本的哈夫曼编码比采用等长方式的编码节省了多少位数？ 
2
解析：
等长编码：4个对象，至少使用2位编码，则编码这段文本需要的编码长度是2*(4+2+5+1)=24。
哈夫曼编码：以出现次数为权，每次选取最小的两个权，从叶往根构造哈夫曼树，那么从根到叶的边数就是该字符的编码长度，编码这段文本需要的编码长度为2*4+3*2+1*5+3*1=22。

2-3
已知一棵完全二叉树的第6层（设根为第1层）有8个叶结点，则该完全二叉树的结点个数最多是：
111
解析：
最多，则将第6层设为次底层，第7层最多有2^(7-1)=64个叶子，由于第6层最右边有8个叶结点，故第7层最多有64-2*8=48个结点，再加上前6层的2^6-1=63个结点，共111个结点。

2-4
三叉树中，度为1的结点有5个，度为2的结点3个，度为3的结点2个，问该树含有几个叶结点？ 
8
解析：
这道题如果用公式不知道怎么算，可以用画图画出来，画出2个度为3的结点……，然后计数即可。度为2的结点，即画一个圆，然后底下伸出两个分支/直线。
下面用公式求。
首先有n个结点的树，有n-1条边，因为除根以外，每个结点都有一条边指向该结点。
故n-1=3*n3+2*n2+n1，联立n=n3+n2+n1+n0，得到2*n3+n2+1=n0，将数值代入即可。

2-5
在并查集问题中，已知集合元素0~8所以对应的父结点编号值分别是{ 1, -4, 1, 1, -3, 4, 4, 8, -2 }（注：−n表示树根且对应集合大小为n），那么将元素6和8所在的集合合并（要求必须将小集合并到大集合）后，该集合对应的树根和父结点编号值分别是多少？ 
4和-5。
解析：
画图即可。

2-6
表达式a*(b+c)-d的后缀表达式是： 
a b c * + d -
解析：
将中缀表达式转换为后缀表达式，用一个栈，维护一个操作符栈，
从头到尾读取中缀表达式的每个对象，对不同对象按不同的情况处理。 
① 运算数：直接输出； 
② 左括号：压入堆栈； 
③ 右括号：将栈顶的运算符弹出并输出，直到遇到左括号（出栈，不输出）； 
④ 运算符： 
	• 若优先级大于栈顶运算符时，则把它压栈（优先级大的操作符要先执行）； 
	• 若优先级小于等于栈顶运算符时，将栈顶运算符弹出并输出；再比较新的栈顶运算符，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈；
⑤ 若各对象处理完毕，则把堆栈中存留的运算符一并输出

这里左括号优先级比乘法运算符高。

2-7
若某图的深度优先搜索序列是{V1, V4, V0, V3, V2}，则下列哪个图不可能对应该序列？ 

2-8
下列哪个函数是O(N)的？ 

2-9
在一个不带头结点的非空链式队列中,假设f和r分别为队头和队尾指针,则插入s所指的结点运算是( )。 
r->next=s; r=s;
解析：
入队即插入，插入到表尾，出队即删除，在表头删除，一定要在表头删除，否则因为是单链表，在表尾删除后，无法依赖next指针顺着找到下一个即将出队的队头元素，时间复杂度就不是O(1)了。

2-10
将{5, 2, 7, 3, 4, 1, 6}依次插入初始为空的二叉搜索树。则该树的后序遍历结果是：
1, 4, 3, 2, 6, 7, 5

2-11
设h为不带头结点的单向链表。在h的头上插入一个新结点t的语句是：
t->next=h; h=t;

2-12
对最小堆（小顶堆）{1,3,2,12,6,4,8,15,14,9,7,5,11,13,10} 进行三次删除最小元的操作后，结果序列为：
4,6,5,12,7,10,8,15,14,9,13,11
解析：
堆是用完全二叉树表示，用数组存储。删除即删除堆顶，取出最后一个元素，开始下滤到合适的插入位置插入。


三、程序填空题：
5-1
下列代码的功能是返回带头结点的单链表L的逆转链表。
List Reverse( List L )
{
    Position Old_head, New_head, Temp;
    New_head = NULL;
    Old_head = L->Next;

    while ( Old_head )  {
        Temp = Old_head->Next;
		Old_head->Next = New_head;  
        New_head = Old_head;  
        Old_head = Temp; 
    }
	L->Next = New_head;
    return L;
}

5-2
下列代码的功能是将小顶堆H中指定位置P上的元素的整数键值下调D个单位，然后继续将H调整为小顶堆。
void DecreaseKey( int P, int D, PriorityQueue H )
{
   int i, key;
   key = H->Elements[P] - D;
   for (i=P; H->Elements[i/2] > key; i/=2)
	H->Elements[i] = H->Elements[i/2];
   H->Elements[i] = key;
}